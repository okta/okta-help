<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:fileTags="Tags/okta-authors.Patrick Calnan">
    <head><title>[%=Heading.Level1%] | Okta</title>
        <link href="" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <h2>How global session policies and <MadCap:variable name="okta-feature-names.app sign-on policies" /> work together</h2>
        <p>In Identity Engine, authentication requests for SAML and OIDC apps must meet the assurance requirements of both the global session policy and the <MadCap:variable name="okta-feature-names.app sign-on policy" />. The global session policy evaluates the user's global session, and the authentication policy evaluates the specific app's requirements. If a valid Okta session already exists, only the authentication policy is evaluated.</p>
        <p>To understand how these concepts work together, review the following setup for an Okta tenant:</p>
        <ul>
            <li>Global session policy has a primary factor requirement of  <span class="uicontrol">Any factor used to meet the Authentication Policy rules</span>, has no secondary factor requirement,  and has a session expiration of two hours.</li>
            <li>Application 1 <MadCap:variable name="okta-feature-names.app sign-on policy" /> is set to <span class="uicontrol">Any 1 factor type / IdP</span> and re-authentication frequency is set to two hours.</li>
            <li>Application 2 <MadCap:variable name="okta-feature-names.app sign-on policy" /> is set to <span class="uicontrol">Any 2 factors types</span> and re-authentication frequency is set to two hours.</li>
            <li>Application 3 <MadCap:variable name="okta-feature-names.app sign-on policy" /> is set to <span class="uicontrol">Any 1 factor type / IdP</span> and re-authentication frequency is set to one hour.</li>
        </ul>
        <p>When the user tries to directly access Application 1, the global session policy is evaluated because an Okta session does not exist yet. Because <span class="uicontrol">Multifactor authentication</span> isn't selected, the user is prompted only for a single factor, as defined by the requirements set on Application 1's authentication policy. The user can use any of their enrolled authenticators  to satisfy Application 1 assurance requirements. For this example, assume they use their password.</p>
        <p>Next, assume that the user tries to access Application 2 in the same browser window, immediately after accessing Application 1. Because Application 2 requires two distinct factor types, and because the user already supplied their password during the Okta session, they  have to supply a different factor type (for example, Okta Verify Push) to satisfy the  assurance requirements for Application 2. </p>
        <p>Finally, assume the user has another session (for example, on a different device or browser) where they were able to access Application 1 using their password as a factor. If the user tries to access Application 3 after one hour of inactivity, they are prompted to re-verify with any of their enrolled factors, which includes password. This is true despite the fact that they already verified with their password previously in the session, because the authentication policy for Application 3 is shorter than the Okta session specified in the global session policy.</p>
        <h2>Before deploying <MadCap:variable name="okta-feature-names.app sign-on policies" /></h2>
        <p>These key considerations should shape your approach to implementing <MadCap:variable name="okta-feature-names.app sign-on policies" />:</p>
        <ul>
            <li>Applications: Some might be simple and have low security requirements (think about a portal to the company cafeteria). Others will have much higher security risks (financial transactions or intellectual property). It's a good practice to start with a simple model containing three assurance levels: low, medium, and high.</li>
            <li>Users: Put them into categories based on the intrinsic risk they bring to the organization. Employees might have different clearance levels. Some third parties might go through security screening, while others might not. These categories will be the foundation to create your user groups in <MadCap:variable name="okta-feature-names.Identity Engine" />. </li>
            <li>Devices: Consider the devices used to access applications. Personal devices or corporate devices are obvious cases. Also consider public devices and devices belonging to friends of an employee.</li>
            <li>Network requirements: Consider whether your users access your org from corporate network, a home network, or a public network.</li>
            <li>Authenticators and authentication methods: Consider which are available and can be enabled for your users. This consideration should include an assessment of the user experience you will deliver.</li>
            <li>User education: Users are the last line of defense. Giving them a basic understanding of the policies and the reason behind them will make them better supporters.</li>
        </ul>
        <p>Defining your <MadCap:variable name="okta-feature-names.app sign-on policy" /> strategy is a multi-dimensional exercise that requires rigor and attention to detail. The following example model illustrates a strategy to deploy app sign-on security to protect your applications. </p>
        <p MadCap:conditions="Primary.do-not-publish"><span class="uicontrol">Note:</span> In the diagram, Context describes the complete context that the user presents to authenticate. It includes the device context, user identity, and groups, as well as network context.</p>
        <h3>Additional considerations</h3>
        <p>Authentication policies are a paradigm shift in IAM for enterprise apps. Keep the following considerations in mind when articulating your strategy, and before deployment:</p>
        <ul>
            <li>IAM is the last line of defense before accessing applications or resources. When designing policies, consider the first lines of defense such as your ISP, routers in your corporate network, and firewalls. The context presented by a user might already have been filtered by other defenses such as IP address ranges or geolocation. However, in a zero-trust scenario, you should assess the context within the policy itself.</li>
            <li>Global session policies supply the context necessary for the user to advance to the next authentication step. They also specify actions to take, such as allowing access, prompting for a challenge, and setting the time before prompting for another challenge. When configuring how frequently <span class="uicontrol">users will be prompted for MFA</span>, be aware of how the options support other conditions like Risk and Behavior:&#160;<ul><li> <span class="uicontrol">When signing in with a new device cookie</span>:&#160;This option reduces MFA for a group of users. Because it allows users to bypass MFA if they appear to be signing in from the same device (based on a browser cookie), it's only appropriate for low-risk, low-assurance use cases. It shouldn't be used with behavior conditions.</li><li><p><span class="uicontrol">At every sign in</span>:&#160;This option prevents users from controlling their own MFA&#160;prompts. This option is suitable for use with behavior conditions, which detect high-risk sign-in events.</p></li><li><p><span class="uicontrol">After MFA&#160;lifetime expires for the device cookie</span>:&#160;This option means that users aren’t challenged again for MFA for the duration of their session unless an app's authentication policy requires it. You can set both a factor lifetime and a session expiration, but be aware that <span class="uicontrol">MFA lifetime</span> is only enforced when a new session is created or if the user changes devices. <span class="uicontrol">Per session</span> is only appropriate for low-risk, low-assurance use cases and shouldn't be used with behavior conditions or risk conditions.</p></li></ul></li>
            <li>Make sure you thoroughly understand the global session policy to <MadCap:variable name="okta-feature-names.app sign-on policy" /> flow. If you choose to delegate to <span class="uicontrol">Any factor used to meet the Authentication Policy rules</span>, pay extra attention to the <MadCap:variable name="okta-feature-names.app sign-on policy" />. For example, if the <MadCap:variable name="okta-feature-names.app sign-on policy" /> is set to <span class="uicontrol">Any 1 factor type</span> and email is enrolled as an authenticator, then the user will have access granted with a simple magic link email.</li>
        </ul>
    </body>
</html>